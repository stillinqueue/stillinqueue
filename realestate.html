<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Still In Queue · Real Estate</title>
  <link rel="icon" type="image/png" href="Fav-Photoroom.png">
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Playfair+Display:wght@500;700&display=swap" rel="stylesheet">

  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg-dark: #020617;
      --text-main: #f9fafb;
      --text-muted: #9ca3af;
      --radius-lg: 1.25rem;
      --radius-xl: 1.75rem;
      --radius-pill: 999px;
      --shadow-soft: 0 18px 45px rgba(15, 23, 42, 0.75);
      --font-sans: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      --font-serif: "Playfair Display", "Times New Roman", serif;
      --transition-fast: 160ms ease-out;
      --transition-med: 260ms ease;
    }

    html { scroll-behavior: smooth; }

    body {
      font-family: var(--font-sans);
      min-height: 100vh;
      color: var(--text-main);
      background: radial-gradient(circle at 0 0, #0b1120 0, #020617 55%, #020617 100%);
    }

    /* Sparkle canvas: full-viewport, never blocks clicks, starts hidden */
    #sparkle-canvas {
      position: fixed; inset: 0;
      width: 100vw; height: 100vh;
      z-index: 50;
      pointer-events: none;
      mix-blend-mode: screen;
      will-change: transform, opacity;
      opacity: 0;
      transition: opacity .18s ease;
    }

    /* ===== Header ===== */
    .site-header {
      position: sticky; top: 0; z-index: 20;
      display: flex; align-items: center; justify-content: space-between;
      padding: 0.6rem 5vw;
      backdrop-filter: blur(18px);
      background: linear-gradient(to bottom, rgba(2,6,23,.96), rgba(2,6,23,.8), transparent);
      border-bottom: 1px solid rgba(148,163,184,.22);
    }

    .logo { display: flex; align-items: center; text-decoration: none; }
    .logo-img { height: 150px; width: auto; display: block; }

    .header-right { display: flex; align-items: center; gap: 1.2rem; }

    .back-link {
      font-size: .78rem; text-transform: uppercase; letter-spacing: .18em;
      text-decoration: none; padding: .45rem 1.1rem; border-radius: var(--radius-pill);
      border: 1px solid rgba(148,163,184,.7);
      background: rgba(15,23,42,.85);
      color: #e5e7eb;
      transition: background var(--transition-fast), border-color var(--transition-fast), transform var(--transition-fast);
    }
    .back-link:hover { background: rgba(30,64,175,.95); border-color: rgba(248,250,252,.9); transform: translateY(-1px); }

    /* ===== Hero ===== */
    .hero {
      position: relative;
      padding: 4.5rem 5vw 2.4rem;
      overflow: hidden; isolation: isolate;
    }

    .hero-bg {
      position: absolute; inset: -35%;
      background:
        radial-gradient(circle at 0 0, rgba(56,189,248,.55), transparent 60%),
        radial-gradient(circle at 100% 10%, rgba(37,99,235,.60), transparent 60%),
        radial-gradient(circle at 55% 120%, rgba(34,197,94,.25), transparent 60%);
      opacity: .9; mix-blend-mode: screen;
      z-index: -2;
    }

    .hero-shell {
      position: absolute; inset: 6%;
      border-radius: 3rem; border: 1px solid rgba(148,163,184,.5);
      background: radial-gradient(circle at top, rgba(15,23,42,.96), rgba(15,23,42,.8), rgba(15,23,42,.4));
      backdrop-filter: blur(26px);
      z-index: -1;
    }

    .hero-inner { max-width: 980px; margin: 0 auto; text-align: center; padding: 2.2rem 0; }
    .hero-kicker { font-size: .8rem; text-transform: uppercase; letter-spacing: .2em; color: #bfdbfe; margin-bottom: .9rem; }
    .hero-title { font-family: var(--font-serif); font-size: clamp(2.2rem, 3.6vw, 3.2rem); letter-spacing: .12em; text-transform: uppercase; margin-bottom: 1rem; }
    .hero-subline { color: var(--text-muted); font-size: .98rem; line-height: 1.8; max-width: 860px; margin: 0 auto; }

    /* ===== Sections ===== */
    .section { padding: 3.2rem 5vw 0; max-width: 1180px; margin: 0 auto; scroll-margin-top: 9rem; }
    .section-chip { text-align: center; margin-bottom: 1.6rem; }
    .section-chip span {
      display: inline-block; padding: .3rem 1.4rem; border-radius: var(--radius-pill);
      border: 1px solid rgba(191,219,254,.95);
      background: linear-gradient(135deg, #1d4ed8, #2563eb, #0ea5e9);
      font-size: .7rem; text-transform: uppercase; letter-spacing: .2em; color: #020617;
    }
    .section-header { display: flex; justify-content: space-between; align-items: baseline; gap: 1rem; margin-bottom: 1.6rem; }
    .section-kicker { font-size: .78rem; text-transform: uppercase; letter-spacing: .18em; color: #93c5fd; margin-bottom: .4rem; }
    .section-title { font-family: var(--font-serif); font-size: 1.4rem; letter-spacing: .08em; text-transform: uppercase; }
    .section-desc { font-size: .9rem; color: var(--text-muted); max-width: 520px; line-height: 1.7; }

    /* ===== Cards ===== */
    .agents-grid { display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 1.4rem; }
    .agent-card {
      border-radius: var(--radius-lg);
      background: radial-gradient(circle at top left, #020617, #020617 45%, #020819 100%);
      border: 1px solid rgba(148,163,184,.35);
      padding: 1.35rem 1.25rem 1.4rem;
      box-shadow: 0 16px 36px rgba(15,23,42,.9);
      position: relative; overflow: hidden;
      transition: transform var(--transition-med), box-shadow var(--transition-med),
                  border-color var(--transition-med), background var(--transition-med);
    }
    .agent-card:hover { transform: translateY(-4px); box-shadow: 0 28px 70px rgba(15,23,42,.9); border-color: rgba(129,140,248,.9); }
    .agent-tag { font-size: .7rem; text-transform: uppercase; letter-spacing: .18em; color: #93c5fd; margin-bottom: .65rem; }
    .agent-title { font-weight: 600; margin-bottom: .35rem; }
    .agent-text { font-size: .9rem; color: var(--text-muted); line-height: 1.6; margin-bottom: .75rem; }
    .agent-meta { font-size: .8rem; color: #e5e7eb; opacity: .9; }
    .agent-meta span { opacity: .8; }

    /* ===== Layout Studio ===== */
    .studio-layout {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.4fr);
      gap: 1.4rem;
      margin-top: .8rem;
    }
    .studio-panel, .studio-preview {
      border-radius: var(--radius-xl);
      background: radial-gradient(circle at top left, #020617, #020617 55%, #02091b 100%);
      border: 1px solid rgba(148,163,184,.45);
      padding: 1.2rem 1.2rem 1.3rem;
      box-shadow: 0 20px 50px rgba(15,23,42,.9);
    }
    .studio-label {
      font-size: .72rem;
      text-transform: uppercase;
      letter-spacing: .18em;
      color: #93c5fd;
      margin-bottom: .6rem;
    }

    /* ===== Chat UI (left side) ===== */
    .chat-shell {
      display: flex;
      flex-direction: column;
      gap: .75rem;
      min-height: 460px;
    }

    .chat-thread {
      flex: 1;
      overflow: auto;
      border-radius: 1rem;
      border: 1px solid rgba(148,163,184,.45);
      background: rgba(15,23,42,.70);
      padding: .85rem;
    }

    .chat-bubble {
      max-width: 92%;
      padding: .65rem .8rem;
      border-radius: 1rem;
      margin-bottom: .55rem;
      font-size: .9rem;
      line-height: 1.55;
      border: 1px solid rgba(148,163,184,.18);
      white-space: pre-wrap;
      word-break: break-word;
    }

    .chat-bubble.user {
      margin-left: auto;
      background: rgba(59,130,246,.18);
      border-color: rgba(59,130,246,.35);
    }
    .chat-bubble.assistant {
      margin-right: auto;
      background: rgba(2,6,23,.55);
      border-color: rgba(148,163,184,.18);
    }

    .chat-meta {
      display: flex; align-items: center; justify-content: space-between;
      gap: .75rem;
      font-size: .75rem;
      color: rgba(148,163,184,.95);
      text-transform: uppercase;
      letter-spacing: .14em;
      margin-top: .15rem;
      margin-bottom: .35rem;
    }

    .chat-input-row {
      display: flex;
      gap: .65rem;
      align-items: center;
    }

    .chat-input {
      flex: 1;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,.45);
      background: rgba(15,23,42,.85);
      color: #e5e7eb;
      padding: .75rem 1rem;
      outline: none;
      font-size: .92rem;
    }
    .chat-input:focus {
      border-color: rgba(191,219,254,.95);
      box-shadow: 0 0 0 3px rgba(59,130,246,.25);
    }

    .chat-send {
      padding: .78rem 1.1rem;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(248,250,252,.85);
      background: linear-gradient(135deg, #3b82f6, #0ea5e9, #22c55e);
      color: #020617;
      font-weight: 700;
      cursor: pointer;
      box-shadow: var(--shadow-soft);
      transition: transform var(--transition-med), filter var(--transition-med), box-shadow var(--transition-med);
      white-space: nowrap;
    }
    .chat-send:hover { transform: translateY(-1px); filter: brightness(1.05); box-shadow: 0 24px 60px rgba(15,23,42,.95); }
    .chat-send:disabled { opacity: .45; cursor: not-allowed; filter: grayscale(1); transform: none; box-shadow: none; }

    /* ===== Action buttons ===== */
    .studio-actions { display: flex; gap: .65rem; flex-wrap: wrap; margin-top: .15rem; }
    .studio-btn {
      padding: .8rem 1.2rem;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(248,250,252,.85);
      background: linear-gradient(135deg, #3b82f6, #0ea5e9, #22c55e);
      color: #020617;
      font-weight: 700;
      cursor: pointer;
      box-shadow: var(--shadow-soft);
      transition: transform var(--transition-med), filter var(--transition-med), box-shadow var(--transition-med);
    }
    .studio-btn:hover { transform: translateY(-1px); filter: brightness(1.05); box-shadow: 0 24px 60px rgba(15,23,42,.95); }
    .studio-btn:disabled { opacity: .45; cursor: not-allowed; filter: grayscale(1); transform: none; box-shadow: none; }

    .studio-btn-secondary {
      padding: .8rem 1.2rem;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(148,163,184,.7);
      background: rgba(15,23,42,.85);
      color: var(--text-main);
      cursor: pointer;
      transition: background var(--transition-fast), border-color var(--transition-fast), transform var(--transition-fast);
    }
    .studio-btn-secondary:hover { background: rgba(30,64,175,.95); border-color: rgba(248,250,252,.9); transform: translateY(-1px); }
    .studio-btn-secondary:disabled { opacity: .45; cursor: not-allowed; transform: none; }

    /* ===== Render progress ===== */
    .progress-wrap {
      margin-top: .55rem;
      display: flex;
      align-items: center;
      gap: .75rem;
      flex-wrap: wrap;
    }
    .progress-bar {
      flex: 1;
      min-width: 220px;
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,.45);
      background: rgba(15,23,42,.55);
      overflow: hidden;
    }
    .progress-bar > div {
      height: 100%;
      width: 0%;
      border-radius: 999px;
      background: linear-gradient(90deg, #3b82f6, #0ea5e9, #22c55e);
      transition: width 240ms ease;
    }
    .progress-text {
      font-size: .85rem;
      color: rgba(226,232,240,.9);
      white-space: nowrap;
    }

    .studio-status { margin-top: .65rem; font-size: .9rem; color: var(--text-muted); line-height: 1.6; }

    /* ===== Preview viewer controls ===== */
    .studio-preview { overflow: hidden; max-height: 70vh; display: flex; flex-direction: column; gap: .65rem; }
    .viewer-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: .55rem;
      align-items: center;
      justify-content: space-between;
    }
    .viewer-controls { display: flex; gap: .5rem; flex-wrap: wrap; }
    .viewer-pill {
      padding: .55rem .9rem;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(148,163,184,.7);
      background: rgba(15,23,42,.85);
      color: var(--text-main);
      cursor: pointer;
      font-size: .85rem;
      transition: background var(--transition-fast), border-color var(--transition-fast), transform var(--transition-fast);
    }
    .viewer-pill:hover { background: rgba(30,64,175,.95); border-color: rgba(248,250,252,.9); transform: translateY(-1px); }

    .viewer-hint {
      font-size: .82rem;
      color: rgba(156,163,175,.95);
      line-height: 1.4;
    }

    .viewer-stage {
      position: relative;
      flex: 1;
      min-height: 420px;
      border-radius: 1rem;
      border: 1px solid rgba(148,163,184,.45);
      background: rgba(15,23,42,.65);
      overflow: hidden;
      touch-action: none;
    }

    .viewer-canvas {
      position: absolute;
      left: 50%;
      top: 50%;
      transform-origin: 0 0;
      will-change: transform;
    }

    .viewer-canvas svg { display: block; max-width: none; height: auto; }

    /* ===== Blueprint legend ===== */
    .legend {
      display: flex;
      gap: .5rem;
      flex-wrap: wrap;
      margin-top: .55rem;
      font-size: .78rem;
      color: rgba(226,232,240,.85);
    }
    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: .4rem;
      padding: .35rem .6rem;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,.35);
      background: rgba(2,6,23,.35);
    }
    .legend-swatch {
      width: 12px; height: 12px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,.25);
    }
    .viewer-3d-note {
      font-size: .78rem;
      color: rgba(148,163,184,.95);
      margin-top: .35rem;
    }

    .site-footer {
      border-top: 1px solid rgba(148,163,184,.25);
      padding: 1.7rem 5vw 2.1rem;
      margin-top: 3.2rem;
      text-align: center;
      font-size: .85rem;
      color: var(--text-muted);
    }

    @media (max-width: 1040px) { .agents-grid { grid-template-columns: repeat(2, minmax(0,1fr)); } }
    @media (max-width: 900px)  { .studio-layout { grid-template-columns: minmax(0,1fr); } .viewer-stage { min-height: 360px; } }
    @media (max-width: 768px)  {
      .site-header { padding-inline: 1.25rem; }
      .hero { padding-inline: 1.5rem; }
      .section { padding-inline: 1.5rem; }
      .section-header { flex-direction: column; align-items: flex-start; }
      .agents-grid { grid-template-columns: minmax(0,1fr); }
      .viewer-stage { min-height: 320px; }
    }
  </style>
</head>

<body>
  <!-- Sparkle canvas -->
  <canvas id="sparkle-canvas" aria-hidden="true"></canvas>

  <header class="site-header">
    <a href="agents.html" class="logo" title="Back to Agents">
      <img src="SQ-AI-Photoroom.png" alt="Still In Queue Group" class="logo-img" />
    </a>

    <div class="header-right">
      <a class="back-link" href="agents.html">← Back to Agents</a>
    </div>
  </header>

  <main class="hero" id="top">
    <div class="hero-bg"></div>
    <div class="hero-shell"></div>

    <div class="hero-inner">
      <div class="hero-kicker">SQ-AI · Design</div>
      <h1 class="hero-title">Real Estate Intelligence</h1>
      <p class="hero-subline">
        Chat-driven layout capture + SVG blueprint preview + PDF export.
        We’ll collect production details in chat (wall thickness, doors, windows, dimensions, scale, north arrow, title block) and pass them to the renderer when integrated.
      </p>
    </div>
  </main>

  <section class="section" id="agents">
    <div class="section-chip"><span>Agents</span></div>

    <div class="section-header">
      <div>
        <div class="section-kicker">Real Estate Agent Library</div>
        <h2 class="section-title">Modules</h2>
      </div>
      <p class="section-desc">
        Layout Studio is live as a prototype. Next versions will produce construction-ready PDFs with full annotation and 3D.
      </p>
    </div>

    <div class="agents-grid">
      <article class="agent-card">
        <div class="agent-tag">Layouts · Design</div>
        <h3 class="agent-title">Layout Studio</h3>
        <p class="agent-text">
          Describe requirements in chat. Render updates the SVG blueprint. Confirm gates PDF download.
        </p>
        <div class="agent-meta">Status: <span>Live</span></div>
      </article>

      <article class="agent-card">
        <div class="agent-tag">Finance · Construction</div>
        <h3 class="agent-title">Cost Estimator</h3>
        <p class="agent-text">
          Estimate rough construction cost and material options (coming soon).
        </p>
        <div class="agent-meta">Status: <span>Coming soon</span></div>
      </article>

      <article class="agent-card">
        <div class="agent-tag">Compliance · Planning</div>
        <h3 class="agent-title">Vastu & Regulations</h3>
        <p class="agent-text">
          Validate layout against basic vastu + setbacks rules (coming soon).
        </p>
        <div class="agent-meta">Status: <span>Coming soon</span></div>
      </article>
    </div>
  </section>

  <section class="section" id="layoutstudio">
    <div class="section-chip"><span>Layout Studio</span></div>

    <div class="section-header">
      <div>
        <div class="section-kicker">Live Demo · Renderer</div>
        <h2 class="section-title">Chat → Render → Confirm → Download</h2>
      </div>
      <p class="section-desc">
        Zoom, rotate, pan, and inspect. Preview is enhanced (colors, dims, grid). PDF export stays as returned by your renderer for now.
      </p>
    </div>

    <div class="studio-layout">
      <!-- LEFT: Chat -->
      <div class="studio-panel">
        <div class="studio-label">AI Layout Agent (Prototype Chat)</div>

        <div class="chat-shell">
          <div class="chat-thread" id="chatThread" aria-live="polite"></div>

          <div class="chat-input-row">
            <input id="chatInput" class="chat-input" type="text"
              placeholder="Ex: Plot 30x40, 2BHK, living north, kitchen east, 9-inch walls, main door 4ft, windows on north…">
            <button id="chatSend" class="chat-send">Send</button>
          </div>

          <div class="studio-actions">
            <button id="btnRender" class="studio-btn">Render Layout</button>
            <button id="btnConfirm" class="studio-btn-secondary" disabled>Confirm Layout</button>
            <button id="btnDownloadPdf" class="studio-btn-secondary" disabled>Download PDF</button>
          </div>

          <!-- Predictable wait UI -->
          <div class="progress-wrap">
            <div class="progress-bar"><div id="progressFill"></div></div>
            <div class="progress-text" id="progressText">Idle</div>
          </div>

          <p id="renderStatus" class="studio-status">
            Describe your plot + rooms + directions. Then click <strong>Render Layout</strong>.
          </p>
        </div>
      </div>

      <!-- RIGHT: Preview -->
      <div class="studio-preview">
        <div class="viewer-toolbar">
          <div>
            <div class="studio-label" style="margin-bottom:.35rem;">Preview (SVG)</div>
            <div class="viewer-hint">Mouse wheel to zoom · Drag to pan · Use rotate buttons</div>
          </div>

          <div class="viewer-controls">
            <button class="viewer-pill" id="zoomIn">Zoom +</button>
            <button class="viewer-pill" id="zoomOut">Zoom −</button>
            <button class="viewer-pill" id="rotateLeft">⟲ Rotate</button>
            <button class="viewer-pill" id="rotateRight">⟳ Rotate</button>
            <button class="viewer-pill" id="resetView">Reset</button>
            <button class="viewer-pill" id="toggle3d">3D View (beta)</button>
          </div>
        </div>

        <div class="viewer-stage" id="viewerStage" aria-label="SVG viewer">
          <div class="viewer-canvas" id="viewerCanvas">
            <div id="preview" style="color: rgba(148,163,184,.8); padding: 1rem;">
              Preview will appear here after rendering.
            </div>
          </div>
        </div>

        <div class="legend" id="legend"></div>
        <div class="viewer-3d-note" id="viewNote" style="display:none;">
          3D is a preview-only visualization (PDF export still uses the backend).
        </div>
      </div>
    </div>
  </section>

  <footer class="site-footer">
    <p>© 2025 Still in Queue · SQ-AI Real Estate. All rights reserved.</p>
  </footer>

  <script>
    (function () {
      // Renderer API (unchanged)
      const RENDER_API = "https://sq-ai-renderer.onrender.com/api/plans/render";

      // OPTIONAL: If/when you connect your OpenAI agent backend, set this to your server endpoint.
      // Example backend: POST /api/realestate/chat  { messages: [...] }  -> { reply: "...", plan?: {...} }
      // For now, this page works without it (local mini-agent).
      const CHAT_API = ""; // e.g. "https://your-domain.com/api/realestate/chat";

      // Elements
      const chatThread = document.getElementById("chatThread");
      const chatInput  = document.getElementById("chatInput");
      const chatSend   = document.getElementById("chatSend");

      const preview    = document.getElementById("preview");
      const statusEl   = document.getElementById("renderStatus");
      const btnRender  = document.getElementById("btnRender");
      const btnConfirm = document.getElementById("btnConfirm");
      const btnPdf     = document.getElementById("btnDownloadPdf");

      const progressFill = document.getElementById("progressFill");
      const progressText = document.getElementById("progressText");
      const legendEl = document.getElementById("legend");
      const toggle3dBtn = document.getElementById("toggle3d");
      const viewNote = document.getElementById("viewNote");

      // Viewer
      const viewerStage  = document.getElementById("viewerStage");
      const viewerCanvas = document.getElementById("viewerCanvas");
      const zoomInBtn    = document.getElementById("zoomIn");
      const zoomOutBtn   = document.getElementById("zoomOut");
      const rotLBtn      = document.getElementById("rotateLeft");
      const rotRBtn      = document.getElementById("rotateRight");
      const resetBtn     = document.getElementById("resetView");

      if (!chatThread || !chatInput || !chatSend || !preview || !statusEl || !btnRender || !btnConfirm || !btnPdf) return;

      // Sample plan (still used as fallback if user hasn't chatted)
      const samplePayload = {
        plan: {
          meta: { title: "30x40 Demo Plan (v1)" },
          plot: { w: 9, h: 12 },
          setbacks: { left: 0.6, right: 0.6, front: 1.2, back: 0.6 },
          // FUTURE fields (ignored by renderer today; used later for construction-ready output)
          production: {
            units: "m",
            wall_thickness: 0.23, // ~9 inch
            scale: "1:100",
            north_arrow: true,
            title_block: { client: "Demo", site: "Hyderabad", sheet: "A1" }
          },
          openings: {
            doors: [],
            windows: []
          },
          rooms: [
            { name: "Living",  x: 0.6, y: 1.2, w: 4.0, h: 3.2 },
            { name: "Kitchen", x: 4.8, y: 1.2, w: 3.0, h: 3.0 },
            { name: "Bed 1",   x: 0.6, y: 4.8, w: 3.6, h: 3.2 },
            { name: "Bath",    x: 4.4, y: 4.8, w: 1.6, h: 2.0 }
          ]
        }
      };

      // State
      const messages = []; // { role: "user"|"assistant", content: string }
      let draftPlan = null; // plan object (NOT payload wrapper)
      let lastPdfBase64 = null;
      let isConfirmed = false;
      let is3D = false;

      function setStatus(html) { statusEl.innerHTML = html; }

      function addMessage(role, content) {
        messages.push({ role, content });

        const meta = document.createElement("div");
        meta.className = "chat-meta";
        meta.innerHTML = `<span>${role === "user" ? "You" : "SQ Agent"}</span><span>${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>`;

        const bubble = document.createElement("div");
        bubble.className = "chat-bubble " + (role === "user" ? "user" : "assistant");
        bubble.textContent = content;

        chatThread.appendChild(meta);
        chatThread.appendChild(bubble);
        chatThread.scrollTop = chatThread.scrollHeight;
      }

      function getPlanPayloadForRender() {
        const plan = draftPlan || samplePayload.plan;
        return { plan };
      }

      // ---------------------------
      // Predictable wait / ETA
      // ---------------------------
      let renderStats = (() => {
        try { return JSON.parse(localStorage.getItem("sq_render_stats") || "{}"); }
        catch { return {}; }
      })();

      function saveRenderStats() {
        localStorage.setItem("sq_render_stats", JSON.stringify(renderStats));
      }

      function avgMs() {
        return Math.max(1200, Math.min(12000, renderStats.avgMs || 3500));
      }

      function bumpAvg(newMs) {
        const a = avgMs();
        const alpha = 0.25;
        renderStats.avgMs = Math.round(a * (1 - alpha) + newMs * alpha);
        renderStats.lastMs = Math.round(newMs);
        renderStats.n = (renderStats.n || 0) + 1;
        saveRenderStats();
      }

      function setProgress(pct, text) {
        if (progressFill) progressFill.style.width = `${Math.max(0, Math.min(100, pct))}%`;
        if (progressText) progressText.textContent = text || "";
      }

      let progTimer = null;
      function startPredictableWait(label) {
        const eta = avgMs();
        const start = performance.now();
        setProgress(3, `${label} (est. ${(eta/1000).toFixed(1)}s)`);
        clearInterval(progTimer);

        progTimer = setInterval(() => {
          const elapsed = performance.now() - start;
          const t = Math.min(1, elapsed / eta);
          const eased = 1 - Math.pow(1 - t, 2.2);
          const pct = 5 + eased * 85; // cap at 90-ish until finished
          const left = Math.max(0, eta - elapsed);
          setProgress(pct, `${label} (est. ${(left/1000).toFixed(1)}s left)`);
        }, 120);
      }

      function finishWait(ms, ok=true) {
        clearInterval(progTimer);
        if (ok) setProgress(100, `Done in ${(ms/1000).toFixed(2)}s`);
        else setProgress(0, `Failed after ${(ms/1000).toFixed(2)}s`);
      }

      // ---------------------------
      // Blueprint theme + overlay
      // ---------------------------
      const ROOM_COLORS = {
        living:  "#3b82f6",
        kitchen: "#22c55e",
        bed:     "#a78bfa",
        bath:    "#f59e0b",
        toilet:  "#f59e0b",
        pooja:   "#14b8a6",
        dining:  "#60a5fa",
        default: "#38bdf8"
      };

      function roomColor(name) {
        const n = (name || "").toLowerCase();
        if (n.includes("living")) return ROOM_COLORS.living;
        if (n.includes("kitchen")) return ROOM_COLORS.kitchen;
        if (n.includes("bed")) return ROOM_COLORS.bed;
        if (n.includes("bath") || n.includes("toilet")) return ROOM_COLORS.bath;
        if (n.includes("pooja")) return ROOM_COLORS.pooja;
        if (n.includes("dining")) return ROOM_COLORS.dining;
        return ROOM_COLORS.default;
      }

      function renderLegend(plan) {
        if (!legendEl) return;
        legendEl.innerHTML = "";
        const uniq = [];
        const used = new Set();
        for (const r of (plan?.rooms || [])) {
          const label = r.name || "Room";
          const color = roomColor(label);
          const k = label + "|" + color;
          if (!used.has(k)) { used.add(k); uniq.push({ label, color }); }
        }
        uniq.slice(0, 12).forEach(it => {
          const div = document.createElement("div");
          div.className = "legend-item";
          div.innerHTML = `<span class="legend-swatch" style="background:${it.color}"></span><span>${it.label}</span>`;
          legendEl.appendChild(div);
        });
      }

      function applySvgThemeAndOverlay(svgString, plan) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svgString, "image/svg+xml");
        const svg = doc.documentElement;

        svg.setAttribute("style", "background: transparent;");

        // Normalize existing strokes/text for dark UI
        svg.querySelectorAll("*").forEach(el => {
          const tag = el.tagName.toLowerCase();
          if (tag === "rect" || tag === "path" || tag === "line" || tag === "polyline" || tag === "polygon") {
            if (!el.getAttribute("stroke")) el.setAttribute("stroke", "rgba(226,232,240,.92)");
            el.setAttribute("stroke-width", el.getAttribute("stroke-width") || "2");
            el.setAttribute("vector-effect", "non-scaling-stroke");
          }
          if (tag === "text") {
            el.setAttribute("fill", "rgba(226,232,240,.95)");
            el.setAttribute("font-family", "Inter, system-ui, sans-serif");
            el.setAttribute("paint-order", "stroke");
            el.setAttribute("stroke", "rgba(2,6,23,.65)");
            el.setAttribute("stroke-width", "3");
          }
        });

        // Add subtle grid background
        const defs = doc.createElementNS("http://www.w3.org/2000/svg", "defs");
        const pattern = doc.createElementNS("http://www.w3.org/2000/svg", "pattern");
        pattern.setAttribute("id", "sqGrid");
        pattern.setAttribute("width", "1");
        pattern.setAttribute("height", "1");
        pattern.setAttribute("patternUnits", "userSpaceOnUse");
        const gridLine = doc.createElementNS("http://www.w3.org/2000/svg", "path");
        gridLine.setAttribute("d", "M 1 0 L 0 0 0 1");
        gridLine.setAttribute("fill", "none");
        gridLine.setAttribute("stroke", "rgba(148,163,184,.18)");
        gridLine.setAttribute("stroke-width", "0.05");
        pattern.appendChild(gridLine);
        defs.appendChild(pattern);
        svg.insertBefore(defs, svg.firstChild);

        const bgRect = doc.createElementNS("http://www.w3.org/2000/svg", "rect");
        bgRect.setAttribute("x", "-9999");
        bgRect.setAttribute("y", "-9999");
        bgRect.setAttribute("width", "19999");
        bgRect.setAttribute("height", "19999");
        bgRect.setAttribute("fill", "url(#sqGrid)");
        svg.insertBefore(bgRect, svg.firstChild);

        // Overlay rooms from plan (professional color + dims + simple doors)
        const overlay = doc.createElementNS("http://www.w3.org/2000/svg", "g");
        overlay.setAttribute("id", "sqOverlay");
        overlay.setAttribute("opacity", "0.95");

        for (const r of (plan?.rooms || [])) {
          const fill = roomColor(r.name);

          const rect = doc.createElementNS("http://www.w3.org/2000/svg", "rect");
          rect.setAttribute("x", String(r.x));
          rect.setAttribute("y", String(r.y));
          rect.setAttribute("width", String(r.w));
          rect.setAttribute("height", String(r.h));
          rect.setAttribute("fill", fill);
          rect.setAttribute("fill-opacity", "0.18");
          rect.setAttribute("stroke", fill);
          rect.setAttribute("stroke-opacity", "0.75");
          rect.setAttribute("stroke-width", "0.08");
          rect.setAttribute("vector-effect", "non-scaling-stroke");
          overlay.appendChild(rect);

          const cx = r.x + r.w / 2;
          const cy = r.y + r.h / 2;

          const title = doc.createElementNS("http://www.w3.org/2000/svg", "text");
          title.setAttribute("x", String(cx));
          title.setAttribute("y", String(cy - 0.15));
          title.setAttribute("text-anchor", "middle");
          title.setAttribute("dominant-baseline", "central");
          title.textContent = r.name || "Room";
          overlay.appendChild(title);

          const dims = doc.createElementNS("http://www.w3.org/2000/svg", "text");
          dims.setAttribute("x", String(cx));
          dims.setAttribute("y", String(cy + 0.20));
          dims.setAttribute("text-anchor", "middle");
          dims.setAttribute("dominant-baseline", "central");
          dims.setAttribute("font-size", "12");
          dims.textContent = `${Number(r.w).toFixed(2)} × ${Number(r.h).toFixed(2)}`;
          overlay.appendChild(dims);

          // Simple door symbol (preview only): bottom-center
          const doorW = Math.min(0.9, r.w * 0.22);
          const doorX = r.x + (r.w - doorW) / 2;
          const doorY = r.y + r.h;
          const door = doc.createElementNS("http://www.w3.org/2000/svg", "path");
          door.setAttribute("d", `M ${doorX} ${doorY} L ${doorX + doorW} ${doorY} M ${doorX} ${doorY} A ${doorW} ${doorW} 0 0 1 ${doorX + doorW} ${doorY - doorW}`);
          door.setAttribute("stroke", "rgba(226,232,240,.92)");
          door.setAttribute("stroke-width", "0.08");
          door.setAttribute("fill", "none");
          door.setAttribute("vector-effect", "non-scaling-stroke");
          overlay.appendChild(door);
        }

        // Plot boundary highlight
        if (plan?.plot?.w && plan?.plot?.h) {
          const b = doc.createElementNS("http://www.w3.org/2000/svg", "rect");
          b.setAttribute("x", "0");
          b.setAttribute("y", "0");
          b.setAttribute("width", String(plan.plot.w));
          b.setAttribute("height", String(plan.plot.h));
          b.setAttribute("fill", "none");
          b.setAttribute("stroke", "rgba(226,232,240,.95)");
          b.setAttribute("stroke-width", "0.12");
          b.setAttribute("vector-effect", "non-scaling-stroke");
          overlay.appendChild(b);
        }

        svg.appendChild(overlay);
        return new XMLSerializer().serializeToString(svg);
      }

      function toIsometric(svgString) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svgString, "image/svg+xml");
        const svg = doc.documentElement;

        const overlay = svg.querySelector("#sqOverlay");
        if (!overlay) return svgString;

        const clone = overlay.cloneNode(true);
        clone.setAttribute("opacity", "0.35");
        clone.setAttribute("transform", "translate(-0.35,-0.35)");

        clone.querySelectorAll("rect").forEach(r => {
          r.setAttribute("fill-opacity", "0.08");
          r.setAttribute("stroke-opacity", "0.55");
        });

        overlay.parentNode.insertBefore(clone, overlay);
        return new XMLSerializer().serializeToString(svg);
      }

      // ---------------------------
      // SVG Viewer: zoom / pan / rotate
      // ---------------------------
      let view = { scale: 1, rotate: 0, tx: 0, ty: 0, dragging: false, lastX: 0, lastY: 0 };

      function applyTransform() {
        if (!viewerCanvas) return;
        const t = `translate(${view.tx}px, ${view.ty}px) rotate(${view.rotate}deg) scale(${view.scale})`;
        viewerCanvas.style.transform = `translate(-50%, -50%) ${t}`;
      }
      function clampScale(s) { return Math.min(8, Math.max(0.2, s)); }

      function zoomBy(factor, anchorClientX=null, anchorClientY=null) {
        const prev = view.scale;
        const next = clampScale(prev * factor);
        if (next === prev) return;

        if (anchorClientX != null && anchorClientY != null && viewerStage) {
          const rect = viewerStage.getBoundingClientRect();
          const ax = anchorClientX - (rect.left + rect.width / 2);
          const ay = anchorClientY - (rect.top + rect.height / 2);
          const f = next / prev;
          view.tx = view.tx - ax * (f - 1);
          view.ty = view.ty - ay * (f - 1);
        }
        view.scale = next;
        applyTransform();
      }

      function rotateBy(deg) { view.rotate = (view.rotate + deg) % 360; applyTransform(); }
      function resetView(silent=false) {
        view.scale = 1; view.rotate = 0; view.tx = 0; view.ty = 0; applyTransform();
        if (!silent) setStatus("View reset ✅");
      }

      function onPointerDown(e) {
        view.dragging = true;
        view.lastX = e.clientX;
        view.lastY = e.clientY;
        viewerStage?.setPointerCapture?.(e.pointerId);
      }
      function onPointerMove(e) {
        if (!view.dragging) return;
        const dx = e.clientX - view.lastX;
        const dy = e.clientY - view.lastY;
        view.lastX = e.clientX;
        view.lastY = e.clientY;
        view.tx += dx; view.ty += dy;
        applyTransform();
      }
      function onPointerUp(e) {
        view.dragging = false;
        viewerStage?.releasePointerCapture?.(e.pointerId);
      }
      function onWheel(e) {
        e.preventDefault();
        const factor = (e.deltaY || 0) > 0 ? 0.92 : 1.08;
        zoomBy(factor, e.clientX, e.clientY);
      }

      // ---------------------------
      // Local prototype "agent" (until OpenAI is wired)
      // It also stores future production fields so you're ready.
      // ---------------------------
      function localAgentReply(userText) {
        const t = (userText || "").toLowerCase();

        // Plot size like 30x40 (feet) OR 9x12 (meters)
        const sizeMatch = t.match(/(\d+(\.\d+)?)\s*x\s*(\d+(\.\d+)?)/);
        let plotW = 9, plotH = 12;
        let units = "m";
        if (sizeMatch) {
          const a = parseFloat(sizeMatch[1]);
          const b = parseFloat(sizeMatch[3]);
          if (a >= 20 || b >= 20) {
            // feet -> meters (approx), store units as m but note original
            plotW = +(a * 0.3048).toFixed(2);
            plotH = +(b * 0.3048).toFixed(2);
            units = "m";
          } else {
            plotW = a; plotH = b;
            units = "m";
          }
        }

        const wants2bhk = t.includes("2bhk") || t.includes("2 bhk");
        const wants3bhk = t.includes("3bhk") || t.includes("3 bhk");

        // wall thickness: "9 inch", "4 inch", "0.23m", "230mm"
        let wall = 0.23;
        const inchMatch = t.match(/(\d+)\s*inch/);
        if (inchMatch) wall = +(parseFloat(inchMatch[1]) * 0.0254).toFixed(2);
        const mmMatch = t.match(/(\d+)\s*mm/);
        if (mmMatch) wall = +(parseFloat(mmMatch[1]) / 1000).toFixed(3);
        const mMatch = t.match(/(\d+(\.\d+)?)\s*m\b/);
        if (mMatch && parseFloat(mMatch[1]) <= 1) wall = +parseFloat(mMatch[1]).toFixed(3);

        // Very rough auto-layout (only to make renderer work)
        const left = 0.6, front = 1.2;
        const usableW = Math.max(2, plotW - 1.2);
        const usableH = Math.max(2, plotH - 1.8);

        const rooms = [];
        rooms.push({ name: "Living",  x: left, y: front, w: +(usableW * 0.52).toFixed(2), h: +(usableH * 0.28).toFixed(2) });
        rooms.push({ name: "Kitchen", x: +(left + usableW * 0.56).toFixed(2), y: front, w: +(usableW * 0.40).toFixed(2), h: +(usableH * 0.26).toFixed(2) });
        rooms.push({ name: "Bed 1", x: left, y: +(front + usableH * 0.33).toFixed(2), w: +(usableW * 0.46).toFixed(2), h: +(usableH * 0.27).toFixed(2) });
        rooms.push({ name: "Bath",  x: +(left + usableW * 0.50).toFixed(2), y: +(front + usableH * 0.33).toFixed(2), w: +(usableW * 0.20).toFixed(2), h: +(usableH * 0.18).toFixed(2) });

        if (wants2bhk || wants3bhk) {
          rooms.push({ name: "Bed 2", x: left, y: +(front + usableH * 0.63).toFixed(2), w: +(usableW * 0.46).toFixed(2), h: +(usableH * 0.25).toFixed(2) });
        }
        if (wants3bhk) {
          rooms.push({ name: "Bed 3", x: +(left + usableW * 0.52).toFixed(2), y: +(front + usableH * 0.63).toFixed(2), w: +(usableW * 0.42).toFixed(2), h: +(usableH * 0.25).toFixed(2) });
        }

        // Store "production-ready" details (future use)
        draftPlan = {
          meta: { title: "Draft Plan (chat)" },
          plot: { w: plotW, h: plotH },
          setbacks: { left: 0.6, right: 0.6, front: 1.2, back: 0.6 },
          production: {
            units,
            wall_thickness: wall,
            // placeholders to be filled by real agent later
            scale: "1:100",
            north_arrow: true,
            title_block: { client: "Client", site: "Site", sheet: "A1" },
            dimension_lines: { outer_plot: true, inner_rooms: true }
          },
          openings: {
            doors: [
              // future schema: { room: "Living", wall: "south", width: 1.0, swing: "left", offset: 0.5 }
            ],
            windows: [
              // future schema: { room: "Bed 1", wall: "north", width: 1.2, sill_height: 0.9, offset: 0.3 }
            ]
          },
          rooms
        };

        const reply =
`Captured a draft.

• Plot: ${plotW} × ${plotH} (units: ${units})
• Wall thickness: ${wall} m
• Rooms: ${rooms.map(r => r.name).join(", ")}

Next, we will collect (via real agent):
- doors (hinge + swing), windows
- dimension lines (outer plot + inner rooms)
- scale + north arrow
- title block

For now, click "Render Layout" to preview.`;

        return { reply, plan: draftPlan };
      }

      async function sendChat() {
        const text = (chatInput.value || "").trim();
        if (!text) return;

        addMessage("user", text);
        chatInput.value = "";

        chatSend.disabled = true;
        chatInput.disabled = true;

        try {
          if (CHAT_API) {
            const res = await fetch(CHAT_API, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ messages }),
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok) throw new Error(data.error || ("Chat failed (HTTP " + res.status + ")"));

            addMessage("assistant", data.reply || "Okay.");
            if (data.plan && typeof data.plan === "object") {
              draftPlan = data.plan;
              setStatus("Draft updated ✅ Click <strong>Render Layout</strong> to preview.");
            } else {
              setStatus("Message received ✅ Click <strong>Render Layout</strong> when ready.");
            }
          } else {
            const out = localAgentReply(text);
            addMessage("assistant", out.reply);
            setStatus("Draft updated ✅ Click <strong>Render Layout</strong> to preview.");
          }

          if (isConfirmed) {
            isConfirmed = false;
            btnPdf.disabled = true;
            btnConfirm.disabled = true;
            setStatus("You changed requirements. Please <strong>Render Layout</strong> again, then <strong>Confirm Layout</strong>.");
          }

        } catch (err) {
          console.error(err);
          addMessage("assistant", "Sorry — I hit a problem. Try again.");
          setStatus("<span style='color:#fca5a5;'>Chat error.</span> Check console.");
        } finally {
          chatSend.disabled = false;
          chatInput.disabled = false;
          chatInput.focus();
        }
      }

      // ---------------------------
      // Render / Confirm / Download
      // ---------------------------
      async function renderNow() {
        btnRender.disabled = true;
        btnConfirm.disabled = true;
        btnPdf.disabled = true;
        lastPdfBase64 = null;
        isConfirmed = false;

        const payload = getPlanPayloadForRender();
        renderLegend(payload.plan);

        setStatus("Rendering...");
        const t0 = performance.now();
        startPredictableWait("Rendering layout");

        try {
          const res = await fetch(RENDER_API, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });

          const data = await res.json().catch(() => ({}));
          const t1 = performance.now();

          if (!res.ok) {
            finishWait(t1 - t0, false);
            const msg = data.error || ("Render failed (HTTP " + res.status + ")");
            setStatus("<span style='color:#fca5a5;'>Render error:</span> " + msg);
            btnRender.disabled = false;
            return;
          }

          bumpAvg(t1 - t0);
          finishWait(t1 - t0, true);

          const rawSvg = data.svg || "";
          let themed = rawSvg ? applySvgThemeAndOverlay(rawSvg, payload.plan) : "(No SVG returned)";
          if (is3D && rawSvg) themed = toIsometric(themed);

          preview.innerHTML = themed || "(No SVG returned)";
          lastPdfBase64 = data.pdf_base64 || null;

          btnConfirm.disabled = false;
          resetView(true);
          setStatus("Rendered ✅ Review in preview. If it looks good, click <strong>Confirm Layout</strong>.");

        } catch (err) {
          const t1 = performance.now();
          finishWait(t1 - t0, false);
          console.error(err);
          setStatus("<span style='color:#fca5a5;'>Network error.</span> Check console.");
        } finally {
          btnRender.disabled = false;
        }
      }

      function confirmLayout() {
        isConfirmed = true;
        const canDownload = !!lastPdfBase64;
        btnPdf.disabled = !canDownload;

        if (canDownload) setStatus("Confirmed ✅ You can now <strong>Download PDF</strong>.");
        else setStatus("Confirmed ✅ (PDF not available from renderer response.)");
      }

      function downloadPdf() {
        if (!lastPdfBase64 || !isConfirmed) return;

        const byteChars = atob(lastPdfBase64);
        const byteNumbers = new Array(byteChars.length);
        for (let i = 0; i < byteChars.length; i++) byteNumbers[i] = byteChars.charCodeAt(i);

        const blob = new Blob([new Uint8Array(byteNumbers)], { type: "application/pdf" });
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = "layout.pdf";
        a.click();

        URL.revokeObjectURL(url);
      }

      // ---------------------------
      // Wire events
      // ---------------------------
      chatSend.addEventListener("click", sendChat);
      chatInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") sendChat();
      });

      btnRender.addEventListener("click", renderNow);
      btnConfirm.addEventListener("click", confirmLayout);
      btnPdf.addEventListener("click", downloadPdf);

      zoomInBtn?.addEventListener("click", () => zoomBy(1.15));
      zoomOutBtn?.addEventListener("click", () => zoomBy(0.87));
      rotLBtn?.addEventListener("click", () => rotateBy(-15));
      rotRBtn?.addEventListener("click", () => rotateBy(15));
      resetBtn?.addEventListener("click", () => resetView(false));

      viewerStage?.addEventListener("pointerdown", onPointerDown);
      viewerStage?.addEventListener("pointermove", onPointerMove);
      viewerStage?.addEventListener("pointerup", onPointerUp);
      viewerStage?.addEventListener("pointercancel", onPointerUp);
      viewerStage?.addEventListener("wheel", onWheel, { passive: false });

      toggle3dBtn?.addEventListener("click", () => {
        is3D = !is3D;
        toggle3dBtn.textContent = is3D ? "3D View: ON" : "3D View (beta)";
        if (viewNote) viewNote.style.display = is3D ? "block" : "none";
        setStatus(is3D
          ? "3D preview enabled (beta). Re-render to apply 3D."
          : "3D preview disabled. Re-render to return to 2D."
        );
      });

      // ---------------------------
      // Boot
      // ---------------------------
      setProgress(0, "Idle");
      btnConfirm.disabled = true;
      btnPdf.disabled = true;
      applyTransform();

      addMessage("assistant",
`Hi! Tell me:
1) Plot size (e.g., 30x40), facing (optional), setbacks (optional)
2) Rooms + counts + directions (N/E/S/W + NE/NW/SE/SW)
3) Production details (optional for now): wall thickness, door widths, window walls, scale, title block

Then click Render Layout.`
      );
    })();
  </script>

  <!-- Sparkle trail (same as agents.html) -->
  <script>
  (() => {
    const canvas = document.getElementById('sparkle-canvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d', { alpha: true });

    const vw = () => Math.max(document.documentElement.clientWidth,  window.innerWidth  || 0);
    const vh = () => Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    const state = { w: 0, h: 0, dpr: Math.min(2, Math.max(1, window.devicePixelRatio || 1)) };

    function resize() {
      canvas.style.width = '100vw';
      canvas.style.height = '100vh';
      const w = vw(), h = vh();
      const dprNow = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
      state.dpr = dprNow;
      canvas.width  = Math.max(1, Math.floor(w * dprNow));
      canvas.height = Math.max(1, Math.floor(h * dprNow));
      ctx.setTransform(dprNow, 0, 0, dprNow, 0, 0);
      state.w = w; state.h = h;
    }
    resize();
    requestAnimationFrame(resize);
    addEventListener('resize', resize);
    if (window.visualViewport) {
      visualViewport.addEventListener('resize', resize);
      visualViewport.addEventListener('scroll', resize);
    }
    matchMedia(`(resolution: ${window.devicePixelRatio || 1}dppx)`).addEventListener?.('change', resize);

    const BLUE   = '#3b82f6';
    const SILVER = '#e5e7eb';

    const STEP        = 4;
    const PER_STEP    = 4;
    const POS_JIT     = 12;
    const POS_JIT_PCT = 0.40;

    const LIFE_MIN    = 900;
    const LIFE_VAR    = 600;
    const FRICTION    = 0.992;
    const GRAVITY     = 0.007;
    const SPEED_JIT   = 1.0;
    const NOISE       = 0.035;

    const STAR_CHANCE = 0.08;
    const STAR_SCALES = [0.9, 1.15, 1.4, 1.8, 2.3];

    const IDLE_DELAY_MS = 120;
    const IDLE_EVERY_MS = 55;
    const IDLE_COUNT    = 2;

    const MAX = 620;
    const P = new Array(MAX).fill(null);
    let head = 0;

    let visible = false;
    let lastNonEmptyAt = performance.now();

    function showCanvas() { if (!visible) { canvas.style.opacity = '1'; visible = true; } }
    function hideCanvas() { if (visible) { canvas.style.opacity = '0'; visible = false; } }

    function addParticle(x, y, vx, vy, color, type='dot') {
      const life = LIFE_MIN + Math.random()*LIFE_VAR;
      const base = (type === 'dot') ? (1.2 + Math.random()*2.6) : (1.0 + Math.random()*1.5);
      const starScale = (type === 'star') ? STAR_SCALES[(Math.random()*STAR_SCALES.length)|0] : 1;
      P[head] = { x, y, vx, vy, life, ttl: life, base, color, type, starScale };
      head = (head + 1) % MAX;
    }

    const hexA = (hex, a) => {
      const n = hex.replace('#','');
      const v = parseInt(n.length===3 ? n.split('').map(c=>c+c).join('') : n, 16);
      const r=(v>>16)&255,g=(v>>8)&255,b=v&255;
      return `rgba(${r},${g},${b},${a})`;
    };

    function drawBubble(x, y, r, color, alpha) {
      const g = ctx.createRadialGradient(x, y, 0, x, y, r);
      g.addColorStop(0.00, hexA(color, Math.min(1, alpha*0.85)));
      g.addColorStop(0.50, hexA(color, Math.min(1, alpha*0.35)));
      g.addColorStop(1.00, hexA(color, 0));
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
    }

    function drawStar5(x, y, outerR, alpha) {
      const innerR = outerR * 0.5;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(-Math.PI/2);
      ctx.beginPath();
      for (let i=0; i<5; i++) {
        const a0 = (i * 2 * Math.PI) / 5;
        const a1 = a0 + Math.PI / 5;
        ctx.lineTo(Math.cos(a0)*outerR, Math.sin(a0)*outerR);
        ctx.lineTo(Math.cos(a1)*innerR, Math.sin(a1)*innerR);
      }
      ctx.closePath();
      ctx.fillStyle = hexA(SILVER, alpha);
      ctx.shadowColor = SILVER;
      ctx.shadowBlur = 14;
      ctx.fill();
      ctx.restore();
    }

    function spawnAt(x, y, segLen, pressed) {
      const count = PER_STEP + (pressed ? 1 : 0);
      const jitterR = POS_JIT + segLen * POS_JIT_PCT;

      for (let i=0; i<count; i++) {
        const angPos = Math.random()*Math.PI*2;
        const jx = Math.cos(angPos) * (Math.random() * jitterR);
        const jy = Math.sin(angPos) * (Math.random() * jitterR);

        const angVel = Math.random()*Math.PI*2;
        const pow = Math.random()*SPEED_JIT;
        const vx = Math.cos(angVel)*pow;
        const vy = Math.sin(angVel)*pow - 0.02;

        addParticle(x + jx, y + jy, vx, vy, BLUE, 'dot');
      }

      if (Math.random() < STAR_CHANCE) {
        const angVel = Math.random()*Math.PI*2;
        const vx = Math.cos(angVel) * 0.28;
        const vy = Math.sin(angVel) * 0.28 - 0.05;
        addParticle(x, y, vx, vy, SILVER, 'star');
      }
    }

    function sampleSpawns(x0, y0, x1, y1, pressed) {
      if (x0 == null || y0 == null) { spawnAt(x1, y1, STEP, pressed); return; }
      const dx = x1 - x0, dy = y1 - y0;
      const dist  = Math.hypot(dx, dy);
      const steps = Math.max(1, Math.floor(dist / STEP));
      const segLen = dist / steps;
      for (let s=1; s<=steps; s++) {
        const t = s / steps;
        spawnAt(x0 + dx*t, y0 + dy*t, segLen, pressed);
      }
    }

    let last = null, down = false;
    let lastMoveAt = performance.now();
    let idleAcc = 0;

    function wake() { showCanvas(); }

    addEventListener('pointerdown', e => {
      down = true; last = { x: e.clientX, y: e.clientY }; lastMoveAt = performance.now();
      wake(); spawnAt(e.clientX, e.clientY, STEP, true);
    }, { passive: true });

    addEventListener('pointerup', () => { down = false; last = null; }, { passive: true });

    addEventListener('pointermove', e => {
      wake();
      const list = e.getCoalescedEvents ? e.getCoalescedEvents() : null;
      if (list && list.length) {
        for (const ev of list) {
          if (last) sampleSpawns(last.x, last.y, ev.clientX, ev.clientY, down);
          else spawnAt(ev.clientX, ev.clientY, STEP, down);
          last = { x: ev.clientX, y: ev.clientY };
        }
      } else {
        const x = e.clientX, y = e.clientY;
        if (last) sampleSpawns(last.x, last.y, x, y, down);
        else spawnAt(x, y, STEP, down);
        last = { x, y };
      }
      lastMoveAt = performance.now();
    }, { passive: true });

    function idleEmit(dt) {
      if (!last) return;
      const since = performance.now() - lastMoveAt;
      if (since < IDLE_DELAY_MS) { idleAcc = 0; return; }
      idleAcc += dt;
      while (idleAcc >= IDLE_EVERY_MS) {
        idleAcc -= IDLE_EVERY_MS;
        for (let i=0; i<IDLE_COUNT; i++) {
          const ang = Math.random() * Math.PI * 2;
          const r   = Math.random() * 18;
          const x = last.x + Math.cos(ang) * r;
          const y = last.y + Math.sin(ang) * r;
          const vang = Math.random() * Math.PI * 2;
          const vpow = Math.random() * 0.5;
          const vx = Math.cos(vang) * vpow;
          const vy = Math.sin(vang) * vpow - 0.02;
          addParticle(x, y, vx, vy, BLUE, 'dot');
        }
        if (Math.random() < 0.12) {
          const vx = (Math.random()-0.5) * 0.3;
          const vy = (Math.random()-0.8) * 0.3;
          addParticle(last.x, last.y, vx, vy, SILVER, 'star');
        }
      }
    }

    let lastFrame = performance.now();
    function tick(now) {
      const dt = now - lastFrame;
      lastFrame = now;

      ctx.clearRect(0, 0, state.w, state.h);
      idleEmit(dt);

      let any = false;
      for (let i=0; i<MAX; i++) {
        const p = P[i];
        if (!p || p.ttl <= 0) continue;

        any = true;

        p.vx += (Math.random()-0.5) * NOISE;
        p.vy += (Math.random()-0.5) * NOISE;

        p.vx *= FRICTION;
        p.vy = p.vy * FRICTION + GRAVITY;
        p.x += p.vx; p.y += p.vy;

        p.ttl -= dt;
        const t = Math.max(0, p.ttl / p.life);
        const alpha = t;
        const r = p.base * (0.7 + 1.8*(1 - t));

        if (p.type === 'dot') drawBubble(p.x, p.y, r, p.color, alpha);
        else drawStar5(p.x, p.y, r * p.starScale, Math.min(1, alpha*0.9));
      }

      if (any) {
        lastNonEmptyAt = now;
        showCanvas();
      } else {
        if (now - lastNonEmptyAt > 220) hideCanvas();
      }

      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    document.addEventListener('visibilitychange', () => { lastFrame = performance.now(); });
  })();
  </script>
</body>
</html>
