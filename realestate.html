<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Still In Queue · Real Estate</title>
  <link rel="icon" type="image/png" href="Fav-Photoroom.png">
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Playfair+Display:wght@500;700&display=swap" rel="stylesheet">

  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg-dark: #020617;
      --text-main: #f9fafb;
      --text-muted: #9ca3af;
      --radius-lg: 1.25rem;
      --radius-xl: 1.75rem;
      --radius-pill: 999px;
      --shadow-soft: 0 18px 45px rgba(15, 23, 42, 0.75);
      --font-sans: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      --font-serif: "Playfair Display", "Times New Roman", serif;
      --transition-fast: 160ms ease-out;
      --transition-med: 260ms ease;
    }

    html { scroll-behavior: smooth; }

    body {
      font-family: var(--font-sans);
      min-height: 100vh;
      color: var(--text-main);
      background: radial-gradient(circle at 0 0, #0b1120 0, #020617 55%, #020617 100%);
    }

    /* Sparkle canvas: full-viewport, never blocks clicks, starts hidden */
    #sparkle-canvas {
      position: fixed; inset: 0;
      width: 100vw; height: 100vh;
      z-index: 50;
      pointer-events: none;
      mix-blend-mode: screen;
      will-change: transform, opacity;
      opacity: 0;
      transition: opacity .18s ease;
    }

    /* ===== Header (match your style) ===== */
    .site-header {
      position: sticky; top: 0; z-index: 20;
      display: flex; align-items: center; justify-content: space-between;
      padding: 0.6rem 5vw;
      backdrop-filter: blur(18px);
      background: linear-gradient(to bottom, rgba(2,6,23,.96), rgba(2,6,23,.8), transparent);
      border-bottom: 1px solid rgba(148,163,184,.22);
    }

    .logo { display: flex; align-items: center; text-decoration: none; }
    .logo-img { height: 150px; width: auto; display: block; }

    .header-right { display: flex; align-items: center; gap: 1.2rem; }

    .back-link {
      font-size: .78rem; text-transform: uppercase; letter-spacing: .18em;
      text-decoration: none; padding: .45rem 1.1rem; border-radius: var(--radius-pill);
      border: 1px solid rgba(148,163,184,.7);
      background: rgba(15,23,42,.85);
      color: #e5e7eb;
      transition: background var(--transition-fast), border-color var(--transition-fast), transform var(--transition-fast);
    }
    .back-link:hover { background: rgba(30,64,175,.95); border-color: rgba(248,250,252,.9); transform: translateY(-1px); }

    /* ===== Hero ===== */
    .hero {
      position: relative;
      padding: 4.5rem 5vw 2.4rem;
      overflow: hidden; isolation: isolate;
    }

    .hero-bg {
      position: absolute; inset: -35%;
      background:
        radial-gradient(circle at 0 0, rgba(56,189,248,.55), transparent 60%),
        radial-gradient(circle at 100% 10%, rgba(37,99,235,.60), transparent 60%),
        radial-gradient(circle at 55% 120%, rgba(34,197,94,.25), transparent 60%);
      opacity: .9; mix-blend-mode: screen;
      z-index: -2;
    }

    .hero-shell {
      position: absolute; inset: 6%;
      border-radius: 3rem; border: 1px solid rgba(148,163,184,.5);
      background: radial-gradient(circle at top, rgba(15,23,42,.96), rgba(15,23,42,.8), rgba(15,23,42,.4));
      backdrop-filter: blur(26px);
      z-index: -1;
    }

    .hero-inner { max-width: 980px; margin: 0 auto; text-align: center; padding: 2.2rem 0; }
    .hero-kicker { font-size: .8rem; text-transform: uppercase; letter-spacing: .2em; color: #bfdbfe; margin-bottom: .9rem; }
    .hero-title { font-family: var(--font-serif); font-size: clamp(2.2rem, 3.6vw, 3.2rem); letter-spacing: .12em; text-transform: uppercase; margin-bottom: 1rem; }
    .hero-subline { color: var(--text-muted); font-size: .98rem; line-height: 1.8; max-width: 820px; margin: 0 auto; }

    /* ===== Sections ===== */
    .section { padding: 3.2rem 5vw 0; max-width: 1180px; margin: 0 auto; scroll-margin-top: 9rem; }
    .section-chip { text-align: center; margin-bottom: 1.6rem; }
    .section-chip span {
      display: inline-block; padding: .3rem 1.4rem; border-radius: var(--radius-pill);
      border: 1px solid rgba(191,219,254,.95);
      background: linear-gradient(135deg, #1d4ed8, #2563eb, #0ea5e9);
      font-size: .7rem; text-transform: uppercase; letter-spacing: .2em; color: #020617;
    }
    .section-header { display: flex; justify-content: space-between; align-items: baseline; gap: 1rem; margin-bottom: 1.6rem; }
    .section-kicker { font-size: .78rem; text-transform: uppercase; letter-spacing: .18em; color: #93c5fd; margin-bottom: .4rem; }
    .section-title { font-family: var(--font-serif); font-size: 1.4rem; letter-spacing: .08em; text-transform: uppercase; }
    .section-desc { font-size: .9rem; color: var(--text-muted); max-width: 460px; line-height: 1.7; }

    /* ===== Cards ===== */
    .agents-grid { display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 1.4rem; }
    .agent-card {
      border-radius: var(--radius-lg);
      background: radial-gradient(circle at top left, #020617, #020617 45%, #020819 100%);
      border: 1px solid rgba(148,163,184,.35);
      padding: 1.35rem 1.25rem 1.4rem;
      box-shadow: 0 16px 36px rgba(15,23,42,.9);
      position: relative; overflow: hidden;
      transition: transform var(--transition-med), box-shadow var(--transition-med),
                  border-color var(--transition-med), background var(--transition-med);
    }
    .agent-card:hover { transform: translateY(-4px); box-shadow: 0 28px 70px rgba(15,23,42,.9); border-color: rgba(129,140,248,.9); }
    .agent-tag { font-size: .7rem; text-transform: uppercase; letter-spacing: .18em; color: #93c5fd; margin-bottom: .65rem; }
    .agent-title { font-weight: 600; margin-bottom: .35rem; }
    .agent-text { font-size: .9rem; color: var(--text-muted); line-height: 1.6; margin-bottom: .75rem; }
    .agent-meta { font-size: .8rem; color: #e5e7eb; opacity: .9; }
    .agent-meta span { opacity: .8; }

    /* ===== Layout Studio ===== */
    .studio-layout {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.4fr);
      gap: 1.4rem;
      margin-top: .8rem;
    }
    .studio-panel, .studio-preview {
      border-radius: var(--radius-xl);
      background: radial-gradient(circle at top left, #020617, #020617 55%, #02091b 100%);
      border: 1px solid rgba(148,163,184,.45);
      padding: 1.2rem 1.2rem 1.3rem;
      box-shadow: 0 20px 50px rgba(15,23,42,.9);
    }
    .studio-label {
      font-size: .72rem;
      text-transform: uppercase;
      letter-spacing: .18em;
      color: #93c5fd;
      margin-bottom: .6rem;
    }
    .studio-textarea {
      width: 100%;
      min-height: 320px;
      resize: vertical;
      border-radius: 1rem;
      border: 1px solid rgba(148,163,184,.45);
      background: rgba(15,23,42,.85);
      color: #e5e7eb;
      padding: .9rem .95rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: .85rem;
      line-height: 1.55;
      outline: none;
    }
    .studio-textarea:focus {
      border-color: rgba(191,219,254,.95);
      box-shadow: 0 0 0 3px rgba(59,130,246,.25);
    }
    .studio-actions { display: flex; gap: .65rem; flex-wrap: wrap; margin-top: .85rem; }
    .studio-btn {
      padding: .8rem 1.2rem;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(248,250,252,.85);
      background: linear-gradient(135deg, #3b82f6, #0ea5e9, #22c55e);
      color: #020617;
      font-weight: 600;
      cursor: pointer;
      box-shadow: var(--shadow-soft);
      transition: transform var(--transition-med), filter var(--transition-med), box-shadow var(--transition-med);
    }
    .studio-btn:hover { transform: translateY(-1px); filter: brightness(1.05); box-shadow: 0 24px 60px rgba(15,23,42,.95); }
    .studio-btn:disabled { opacity: .45; cursor: not-allowed; filter: grayscale(1); transform: none; box-shadow: none; }

    .studio-btn-secondary {
      padding: .8rem 1.2rem;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(148,163,184,.7);
      background: rgba(15,23,42,.85);
      color: var(--text-main);
      cursor: pointer;
      transition: background var(--transition-fast), border-color var(--transition-fast), transform var(--transition-fast);
    }
    .studio-btn-secondary:hover { background: rgba(30,64,175,.95); border-color: rgba(248,250,252,.9); transform: translateY(-1px); }
    .studio-btn-secondary:disabled { opacity: .45; cursor: not-allowed; transform: none; }

    .studio-status { margin-top: .85rem; font-size: .9rem; color: var(--text-muted); line-height: 1.6; }
    .studio-preview { overflow: auto; max-height: 70vh; }
    .studio-preview svg { max-width: 100%; height: auto; display: block; }

    .site-footer { border-top: 1px solid rgba(148,163,184,.25); padding: 1.7rem 5vw 2.1rem; margin-top: 3.2rem; text-align: center; font-size: .85rem; color: var(--text-muted); }

    @media (max-width: 1040px) { .agents-grid { grid-template-columns: repeat(2, minmax(0,1fr)); } }
    @media (max-width: 900px)  { .studio-layout { grid-template-columns: minmax(0,1fr); } }
    @media (max-width: 768px)  {
      .site-header { padding-inline: 1.25rem; }
      .hero { padding-inline: 1.5rem; }
      .section { padding-inline: 1.5rem; }
      .section-header { flex-direction: column; align-items: flex-start; }
      .agents-grid { grid-template-columns: minmax(0,1fr); }
      .studio-textarea { min-height: 260px; }
      .studio-preview { max-height: 55vh; }
    }
  </style>
</head>

<body>
  <!-- Sparkle canvas -->
  <canvas id="sparkle-canvas" aria-hidden="true"></canvas>

  <header class="site-header">
    <a href="agents.html" class="logo" title="Back to Agents">
      <img src="SQ-AI-Photoroom.png" alt="Still In Queue Group" class="logo-img" />
    </a>

    <div class="header-right">
      <a class="back-link" href="agents.html">← Back to Agents</a>
    </div>
  </header>

  <main class="hero" id="top">
    <div class="hero-bg"></div>
    <div class="hero-shell"></div>

    <div class="hero-inner">
      <div class="hero-kicker">SQ-AI · Design</div>
      <h1 class="hero-title">Real Estate Intelligence</h1>
      <p class="hero-subline">
        A vertical inside SQ-AI for layout planning and design iteration.
        Today: Layout Studio preview + PDF export. Next: chat-driven revisions, vastu, and cost estimation.
      </p>
    </div>
  </main>

  <section class="section" id="agents">
    <div class="section-chip"><span>Agents</span></div>

    <div class="section-header">
      <div>
        <div class="section-kicker">Real Estate Agent Library</div>
        <h2 class="section-title">Modules</h2>
      </div>
      <p class="section-desc">
        Each module becomes its own agent later. Layout Studio is live right now.
      </p>
    </div>

    <div class="agents-grid">
      <article class="agent-card">
        <div class="agent-tag">Layouts · Design</div>
        <h3 class="agent-title">Layout Studio</h3>
        <p class="agent-text">
          Generate plot-aware floor layouts. Preview instantly in SVG and export PDF.
        </p>
        <div class="agent-meta">Status: <span>Live</span></div>
      </article>

      <article class="agent-card">
        <div class="agent-tag">Finance · Construction</div>
        <h3 class="agent-title">Cost Estimator</h3>
        <p class="agent-text">
          Estimate rough construction cost and material options (coming soon).
        </p>
        <div class="agent-meta">Status: <span>Coming soon</span></div>
      </article>

      <article class="agent-card">
        <div class="agent-tag">Compliance · Planning</div>
        <h3 class="agent-title">Vastu & Regulations</h3>
        <p class="agent-text">
          Validate layout against basic vastu + setbacks rules (coming soon).
        </p>
        <div class="agent-meta">Status: <span>Coming soon</span></div>
      </article>
    </div>
  </section>

  <section class="section" id="layoutstudio">
    <div class="section-chip"><span>Layout Studio</span></div>

    <div class="section-header">
      <div>
        <div class="section-kicker">Live Demo · Renderer</div>
        <h2 class="section-title">Generate & Export</h2>
      </div>
      <p class="section-desc">
        Edit the JSON, render the layout, and download a PDF.
      </p>
    </div>

    <div class="studio-layout">
      <div class="studio-panel">
        <div class="studio-label">Plan JSON</div>
        <textarea id="planJson" class="studio-textarea" spellcheck="false"></textarea>

        <div class="studio-actions">
          <button id="btnRender" class="studio-btn">Render Layout</button>
          <button id="btnDownloadPdf" class="studio-btn-secondary" disabled>Download PDF</button>
          <button id="btnLoadSample" class="studio-btn-secondary">Load Sample</button>
        </div>

        <p id="renderStatus" class="studio-status">
          Tip: change room sizes/positions and click <strong>Render Layout</strong>.
        </p>
      </div>

      <div class="studio-preview">
        <div class="studio-label">Preview (SVG)</div>
        <div id="preview" style="margin-top:.75rem; color: rgba(148,163,184,.8);">
          Preview will appear here after rendering.
        </div>
      </div>
    </div>
  </section>

  <footer class="site-footer">
    <p>© 2025 Still in Queue · SQ-AI Real Estate. All rights reserved.</p>
  </footer>

  <script>
    (function () {
      const API = "https://sq-ai-renderer.onrender.com/api/plans/render";

      const planBox = document.getElementById("planJson");
      const preview = document.getElementById("preview");
      const statusEl = document.getElementById("renderStatus");
      const btnRender = document.getElementById("btnRender");
      const btnPdf = document.getElementById("btnDownloadPdf");
      const btnSample = document.getElementById("btnLoadSample");

      if (!planBox || !preview || !statusEl || !btnRender || !btnPdf || !btnSample) return;

      const samplePayload = {
        plan: {
          meta: { title: "30x40 Demo Plan (v1)" },
          plot: { w: 9, h: 12 },
          setbacks: { left: 0.6, right: 0.6, front: 1.2, back: 0.6 },
          rooms: [
            { name: "Living",  x: 0.6, y: 1.2, w: 4.0, h: 3.2 },
            { name: "Kitchen", x: 4.8, y: 1.2, w: 3.0, h: 3.0 },
            { name: "Bed 1",   x: 0.6, y: 4.8, w: 3.6, h: 3.2 },
            { name: "Bath",    x: 4.4, y: 4.8, w: 1.6, h: 2.0 }
          ]
        }
      };

      let lastPdfBase64 = null;

      function setStatus(html) { statusEl.innerHTML = html; }

      function loadSample() {
        planBox.value = JSON.stringify(samplePayload, null, 2);
        setStatus("Loaded sample. Click <strong>Render Layout</strong>.");
      }

      async function renderNow() {
        btnRender.disabled = true;
        btnPdf.disabled = true;
        lastPdfBase64 = null;
        setStatus("Rendering...");

        let payload;
        try {
          payload = JSON.parse(planBox.value);
        } catch (e) {
          setStatus("<span style='color:#fca5a5;'>Invalid JSON.</span> Please fix the JSON and try again.");
          btnRender.disabled = false;
          return;
        }

        try {
          const res = await fetch(API, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });

          const data = await res.json().catch(() => ({}));

          if (!res.ok) {
            const msg = data.error || ("Render failed (HTTP " + res.status + ")");
            setStatus("<span style='color:#fca5a5;'>Render error:</span> " + msg);
            btnRender.disabled = false;
            return;
          }

          preview.innerHTML = data.svg || "(No SVG returned)";
          lastPdfBase64 = data.pdf_base64 || null;
          btnPdf.disabled = !lastPdfBase64;

          setStatus("Done ✅ Layout updated.");
        } catch (err) {
          console.error(err);
          setStatus("<span style='color:#fca5a5;'>Network error.</span> Check console.");
        } finally {
          btnRender.disabled = false;
        }
      }

      function downloadPdf() {
        if (!lastPdfBase64) return;

        const byteChars = atob(lastPdfBase64);
        const byteNumbers = new Array(byteChars.length);
        for (let i = 0; i < byteChars.length; i++) byteNumbers[i] = byteChars.charCodeAt(i);

        const blob = new Blob([new Uint8Array(byteNumbers)], { type: "application/pdf" });
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = "layout.pdf";
        a.click();

        URL.revokeObjectURL(url);
      }

      btnRender.addEventListener("click", renderNow);
      btnPdf.addEventListener("click", downloadPdf);
      btnSample.addEventListener("click", loadSample);

      loadSample();
    })();
  </script>

  <!-- Sparkle trail (same as agents.html) -->
  <script>
  (() => {
    const canvas = document.getElementById('sparkle-canvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d', { alpha: true });

    const vw = () => Math.max(document.documentElement.clientWidth,  window.innerWidth  || 0);
    const vh = () => Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    const state = { w: 0, h: 0, dpr: Math.min(2, Math.max(1, window.devicePixelRatio || 1)) };

    function resize() {
      canvas.style.width = '100vw';
      canvas.style.height = '100vh';
      const w = vw(), h = vh();
      const dprNow = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
      state.dpr = dprNow;
      canvas.width  = Math.max(1, Math.floor(w * dprNow));
      canvas.height = Math.max(1, Math.floor(h * dprNow));
      ctx.setTransform(dprNow, 0, 0, dprNow, 0, 0);
      state.w = w; state.h = h;
    }
    resize();
    requestAnimationFrame(resize);
    addEventListener('resize', resize);
    if (window.visualViewport) {
      visualViewport.addEventListener('resize', resize);
      visualViewport.addEventListener('scroll', resize);
    }
    matchMedia(`(resolution: ${window.devicePixelRatio || 1}dppx)`).addEventListener?.('change', resize);

    const BLUE   = '#3b82f6';
    const SILVER = '#e5e7eb';

    const STEP        = 4;
    const PER_STEP    = 4;
    const POS_JIT     = 12;
    const POS_JIT_PCT = 0.40;

    const LIFE_MIN    = 900;
    const LIFE_VAR    = 600;
    const FRICTION    = 0.992;
    const GRAVITY     = 0.007;
    const SPEED_JIT   = 1.0;
    const NOISE       = 0.035;

    const STAR_CHANCE = 0.08;
    const STAR_SCALES = [0.9, 1.15, 1.4, 1.8, 2.3];

    const IDLE_DELAY_MS = 120;
    const IDLE_EVERY_MS = 55;
    const IDLE_COUNT    = 2;

    const MAX = 620;
    const P = new Array(MAX).fill(null);
    let head = 0;

    let visible = false;
    let lastNonEmptyAt = performance.now();

    function showCanvas() { if (!visible) { canvas.style.opacity = '1'; visible = true; } }
    function hideCanvas() { if (visible) { canvas.style.opacity = '0'; visible = false; } }

    function addParticle(x, y, vx, vy, color, type='dot') {
      const life = LIFE_MIN + Math.random()*LIFE_VAR;
      const base = (type === 'dot') ? (1.2 + Math.random()*2.6) : (1.0 + Math.random()*1.5);
      const starScale = (type === 'star') ? STAR_SCALES[(Math.random()*STAR_SCALES.length)|0] : 1;
      P[head] = { x, y, vx, vy, life, ttl: life, base, color, type, starScale };
      head = (head + 1) % MAX;
    }

    const hexA = (hex, a) => {
      const n = hex.replace('#','');
      const v = parseInt(n.length===3 ? n.split('').map(c=>c+c).join('') : n, 16);
      const r=(v>>16)&255,g=(v>>8)&255,b=v&255;
      return `rgba(${r},${g},${b},${a})`;
    };

    function drawBubble(x, y, r, color, alpha) {
      const g = ctx.createRadialGradient(x, y, 0, x, y, r);
      g.addColorStop(0.00, hexA(color, Math.min(1, alpha*0.85)));
      g.addColorStop(0.50, hexA(color, Math.min(1, alpha*0.35)));
      g.addColorStop(1.00, hexA(color, 0));
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
    }

    function drawStar5(x, y, outerR, alpha) {
      const innerR = outerR * 0.5;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(-Math.PI/2);
      ctx.beginPath();
      for (let i=0; i<5; i++) {
        const a0 = (i * 2 * Math.PI) / 5;
        const a1 = a0 + Math.PI / 5;
        ctx.lineTo(Math.cos(a0)*outerR, Math.sin(a0)*outerR);
        ctx.lineTo(Math.cos(a1)*innerR, Math.sin(a1)*innerR);
      }
      ctx.closePath();
      ctx.fillStyle = hexA(SILVER, alpha);
      ctx.shadowColor = SILVER;
      ctx.shadowBlur = 14;
      ctx.fill();
      ctx.restore();
    }

    function spawnAt(x, y, segLen, pressed) {
      const count = PER_STEP + (pressed ? 1 : 0);
      const jitterR = POS_JIT + segLen * POS_JIT_PCT;

      for (let i=0; i<count; i++) {
        const angPos = Math.random()*Math.PI*2;
        const jx = Math.cos(angPos) * (Math.random() * jitterR);
        const jy = Math.sin(angPos) * (Math.random() * jitterR);

        const angVel = Math.random()*Math.PI*2;
        const pow = Math.random()*SPEED_JIT;
        const vx = Math.cos(angVel)*pow;
        const vy = Math.sin(angVel)*pow - 0.02;

        addParticle(x + jx, y + jy, vx, vy, BLUE, 'dot');
      }

      if (Math.random() < STAR_CHANCE) {
        const angVel = Math.random()*Math.PI*2;
        const vx = Math.cos(angVel) * 0.28;
        const vy = Math.sin(angVel) * 0.28 - 0.05;
        addParticle(x, y, vx, vy, SILVER, 'star');
      }
    }

    function sampleSpawns(x0, y0, x1, y1, pressed) {
      if (x0 == null || y0 == null) { spawnAt(x1, y1, STEP, pressed); return; }
      const dx = x1 - x0, dy = y1 - y0;
      const dist  = Math.hypot(dx, dy);
      const steps = Math.max(1, Math.floor(dist / STEP));
      const segLen = dist / steps;
      for (let s=1; s<=steps; s++) {
        const t = s / steps;
        spawnAt(x0 + dx*t, y0 + dy*t, segLen, pressed);
      }
    }

    let last = null, down = false;
    let lastMoveAt = performance.now();
    let idleAcc = 0;

    function wake() { showCanvas(); }

    addEventListener('pointerdown', e => {
      down = true; last = { x: e.clientX, y: e.clientY }; lastMoveAt = performance.now();
      wake(); spawnAt(e.clientX, e.clientY, STEP, true);
    }, { passive: true });

    addEventListener('pointerup', () => { down = false; last = null; }, { passive: true });

    addEventListener('pointermove', e => {
      wake();
      const list = e.getCoalescedEvents ? e.getCoalescedEvents() : null;
      if (list && list.length) {
        for (const ev of list) {
          if (last) sampleSpawns(last.x, last.y, ev.clientX, ev.clientY, down);
          else spawnAt(ev.clientX, ev.clientY, STEP, down);
          last = { x: ev.clientX, y: ev.clientY };
        }
      } else {
        const x = e.clientX, y = e.clientY;
        if (last) sampleSpawns(last.x, last.y, x, y, down);
        else spawnAt(x, y, STEP, down);
        last = { x, y };
      }
      lastMoveAt = performance.now();
    }, { passive: true });

    function idleEmit(dt) {
      if (!last) return;
      const since = performance.now() - lastMoveAt;
      if (since < IDLE_DELAY_MS) { idleAcc = 0; return; }
      idleAcc += dt;
      while (idleAcc >= IDLE_EVERY_MS) {
        idleAcc -= IDLE_EVERY_MS;
        for (let i=0; i<IDLE_COUNT; i++) {
          const ang = Math.random() * Math.PI * 2;
          const r   = Math.random() * 18;
          const x = last.x + Math.cos(ang) * r;
          const y = last.y + Math.sin(ang) * r;
          const vang = Math.random() * Math.PI * 2;
          const vpow = Math.random() * 0.5;
          const vx = Math.cos(vang) * vpow;
          const vy = Math.sin(vang) * vpow - 0.02;
          addParticle(x, y, vx, vy, BLUE, 'dot');
        }
        if (Math.random() < 0.12) {
          const vx = (Math.random()-0.5) * 0.3;
          const vy = (Math.random()-0.8) * 0.3;
          addParticle(last.x, last.y, vx, vy, SILVER, 'star');
        }
      }
    }

    let lastFrame = performance.now();
    function tick(now) {
      const dt = now - lastFrame;
      lastFrame = now;

      ctx.clearRect(0, 0, state.w, state.h);
      idleEmit(dt);

      let any = false;
      for (let i=0; i<MAX; i++) {
        const p = P[i];
        if (!p || p.ttl <= 0) continue;

        any = true;

        p.vx += (Math.random()-0.5) * NOISE;
        p.vy += (Math.random()-0.5) * NOISE;

        p.vx *= FRICTION;
        p.vy = p.vy * FRICTION + GRAVITY;
        p.x += p.vx; p.y += p.vy;

        p.ttl -= dt;
        const t = Math.max(0, p.ttl / p.life);
        const alpha = t;
        const r = p.base * (0.7 + 1.8*(1 - t));

        if (p.type === 'dot') drawBubble(p.x, p.y, r, p.color, alpha);
        else drawStar5(p.x, p.y, r * p.starScale, Math.min(1, alpha*0.9));
      }

      if (any) {
        lastNonEmptyAt = now;
        showCanvas();
      } else {
        if (now - lastNonEmptyAt > 220) hideCanvas();
      }

      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    document.addEventListener('visibilitychange', () => { lastFrame = performance.now(); });
  })();
  </script>
</body>
</html>
